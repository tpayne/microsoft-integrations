<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: pane.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: pane.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * CommsAssist main script (complete)
 * - Copy this file as-is to your add-in JS bundle.
 * - Requires a server-side proxy at getVar("proxy_gen_endpoint") or DEFAULT_PROXY_ENDPOINT.
 * - Production note: replace sanitizeHtml with DOMPurify server-side or client-side sanitization.
 */

/* ============================
   JSDoc typedefs (parser-friendly)
   ============================ */

/**
 * ComposeBackupStore shape used by the module
 * @typedef {Object} ComposeBackupStore
 * @property {string|null} lastBackup
 * @property {function():Promise&lt;void>} [saveBackup] - saves the current compose HTML
 * @property {function():Promise&lt;boolean>} [restoreBackup] - restores the last backup, resolves true on success
 */

/**
 * Options for setDraftBody
 * @typedef {Object} SetDraftOptions
 * @property {boolean} [createBackup] - whether to save a backup before applying the draft
 */

/**
 * Normalized model result when returned by the proxy or normalized by the client
 * @typedef {Object} NormalizedResult
 * @property {string} [text] - plain text response from the model
 * @property {{name: string, args: any}} [functionCall] - function call payload when model requests an action
 */

/**
 * Options for callGeminiAPI
 * @typedef {Object} CallGeminiOptions
 * @property {number} [timeoutMs]
 * @property {number} [maxAttempts]
 * @property {number} [baseDelayMs]
 * @property {Object} [apiParams]
 */

/* ============================
   Config, state, and constants
   ============================ */

/** @type {Map&lt;string, any>} */
let configMap = new Map();

/** @type {string} Last generated HTML draft (module-scoped) */
let draft = "";

/** @type {ComposeBackupStore} */
const composeBackupStore = { lastBackup: null };

const HISTORY_CAP = 50;
const DEFAULT_PROXY_ENDPOINT = "/api/gen"; // change if your proxy URL differs
const REQUEST_TIMEOUT_MS = 30000;

/* ============================
   Utilities and DOM helpers
   ============================ */

/**
 * Logs a debug message to the console.
 * @param {string} message
 */
function log(message) {
  console.log(`[DEBUG] ${message}`);
}

/**
 * Retrieves a value from the loaded config map.
 * If the value is an array it joins with newline.
 * @param {string} key
 * @returns {any}
 */
function getVar(key) {
  if (configMap.size !== 0) {
    const value = configMap.get(key);
    if (Array.isArray(value)) return value.join(String.fromCharCode(10));
    return value;
  }
  return "";
}

/**
 * Loads a JSON config file and stores its key/values in configMap.
 * @param {string} url - URL to config.json
 * @returns {Promise&lt;void>}
 */
async function loadConfig(url) {
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
    const parsedData = await res.json();
    for (const key in parsedData) configMap.set(key, parsedData[key]);
  } catch (err) {
    console.error(`Failed to load configuration: ${err.message}`);
    throw err;
  }
}

/**
 * Shows an error message in the response container (or alert if missing).
 * @param {string} msg
 * @returns {void}
 */
function showError(msg) {
  const rc = document.getElementById("responseContainer");
  if (rc) {
    rc.textContent = msg;
    rc.classList.add("error");
    rc.setAttribute("role", "alert");
    try {
      rc.focus();
    } catch (e) {
      // Focus may fail in some hosts; ignore
      log("showError: focus failed ",e);
    }
  } else {
    window.alert(msg);
  }
}

/**
 * Removes triple-backtick html fences from generated content.
 * @param {string} content
 * @returns {string}
 */
function removeHtmlFences(content) {
  const fence = "```html" + String.fromCharCode(10);
  if (typeof content === "string" &amp;&amp; content.startsWith(fence) &amp;&amp; content.endsWith("```")) {
    return content.slice(fence.length, -3);
  }
  return content;
}

/**
 * Keeps chat history capped to avoid memory bloat.
 * @param {number} [max=HISTORY_CAP]
 */
function capHistory(max = HISTORY_CAP) {
  const history = document.getElementById("chatHistory");
  if (!history) return;
  while (history.children.length > max) history.removeChild(history.firstChild);
}

/**
 * Minimal HTML sanitizer: strips &lt;script> tags and inline event handlers.
 * Replace with DOMPurify for production.
 * @param {string} html
 * @returns {string}
 */
function sanitizeHtml(html) {
  return String(html || "")
    .replace(/&lt;script[\s\S]*?>[\s\S]*?&lt;\/script>/gi, "")
    .replace(/\son\w+=(["'])([\s\S]*?)\1/gi, "")
    .replace(/javascript:/gi, "");
}

/**
 * Appends a chat message bubble into chat history.
 * @param {string} text
 * @param {'user'|'ai'} sender
 * @returns {HTMLElement|null} The appended element or null.
 */
function appendMessage(text, sender) {
  const history = document.getElementById("chatHistory");
  if (!history) return null;
  const messageEl = document.createElement("div");
  messageEl.classList.add("message", `${sender}-message`);
  messageEl.dataset.sender = sender;
  messageEl.textContent = text;
  history.appendChild(messageEl);
  capHistory();
  history.scrollTop = history.scrollHeight;
  return messageEl;
}

/* ============================
   Office theme integration
   ============================ */

/**
 * Safely applies Office theme colors into CSS variables.
 * Falls back to sensible defaults when tokens or getComputedStyle are unavailable.
 * @param {Object} theme
 */
function applyOfficeThemeVars(theme) {
  if (!theme) return;
  const FALLBACKS = {
    bg: "#ffffff",
    surface: "#fbfcfd",
    text: "#111827",
    border: "#e6e9ee",
    muted: "#6b7280",
    accent: "#0f64ff",
    shadow: "0 1px 2px rgba(16,24,40,0.04)",
  };
  function readCssVar(name) {
    try {
      if (typeof window !== "undefined" &amp;&amp; typeof window.getComputedStyle === "function") {
        const comp = window.getComputedStyle(document.documentElement);
        const val = comp.getPropertyValue(name);
        if (val) return val.trim();
      }
    } catch (readErr) {
      log("readCssVar getComputedStyle failed: " + (readErr &amp;&amp; readErr.message));
    }
    try {
      const inline = document.documentElement.style.getPropertyValue(name);
      if (inline) return inline.trim();
    } catch (inlineErr) {
      log("readCssVar inline style read failed: " + (inlineErr &amp;&amp; inlineErr.message));
    }
    const key = name.replace(/^--/, "");
    return FALLBACKS[key] || "";
  }
  const currentBg = readCssVar("--bg") || FALLBACKS.bg;
  const currentText = readCssVar("--text") || FALLBACKS.text;
  const bodyBg =
    theme.bodyBackgroundColor &amp;&amp; String(theme.bodyBackgroundColor).trim()
      ? theme.bodyBackgroundColor
      : currentBg;
  const bodyFg =
    theme.bodyForegroundColor &amp;&amp; String(theme.bodyForegroundColor).trim()
      ? theme.bodyForegroundColor
      : currentText;
  try {
    document.documentElement.style.setProperty("--bg", bodyBg);
    document.documentElement.style.setProperty("--surface", bodyBg);
    document.documentElement.style.setProperty("--text", bodyFg);
    if (theme.bodyBorderColor) document.documentElement.style.setProperty("--border", theme.bodyBorderColor);
    if (theme.bodySubtleColor) document.documentElement.style.setProperty("--muted", theme.bodySubtleColor);
  } catch (e) {
    console.warn("applyOfficeThemeVars failed", e);
  }
}

/**
 * Registers the Office theme change handler if available.
 * Uses mailbox.addHandlerAsync to watch for OfficeThemeChanged events.
 */
function registerThemeChangeHandler() {
  try {
    const mailbox = window.Office?.context?.mailbox;
    if (!mailbox || !window.Office.EventType?.OfficeThemeChanged) return;
    mailbox.addHandlerAsync(
      Office.EventType.OfficeThemeChanged,
      function (eventArgs) {
        applyOfficeThemeVars(eventArgs?.officeTheme);
      },
      function (result) {
        if (result &amp;&amp; result.status === Office.AsyncResultStatus.Failed) {
          console.error("Failed to register theme change handler:", result.error &amp;&amp; result.error.message);
        } else {
          try {
            const currentTheme = mailbox.officeTheme;
            if (currentTheme) applyOfficeThemeVars(currentTheme);
          } catch (e) {
            log("registerThemeChangeHandler: reading mailbox.officeTheme failed: " + (e &amp;&amp; e.message));
          }
          console.debug("Theme change handler registered.");
        }
      }
    );
  } catch (e) {
    console.warn("Office theming not available", e);
  }
}

/* -------------------------
   DOM helpers and UI updates
   ------------------------- */

/**
 * Sets the metadata for the email pane.
 * @param {string} sentiment - The sentiment of the email.
 * @param {string} urgency - The urgency of the email.
 * @param {string} intention - The intention of the email.
 * @returns {void}
 */
function setMetaData(sentiment, urgency, intention) {
  // Logs the retrieved metadata
  log(`Email Metadata - Sentiment: ${sentiment}, Urgency: ${urgency}, Intention: ${intention}`);

  // Get the indicator element
  const urgencyIndicator = document.getElementById("urgencyIndicator");

  // Updates the UI with the retrieved metadata
  const sentimentEl = document.getElementById("sentiment");
  const urgencyEl = document.getElementById("urgency");
  const intentionEl = document.getElementById("intention");

  if (sentimentEl) sentimentEl.textContent = sentiment ?? "—";
  if (urgencyEl) urgencyEl.textContent = urgency ?? "—";
  if (intentionEl) intentionEl.textContent = intention ?? "—";

  // Update urgency indicator color
  if (urgencyIndicator) {
    urgencyIndicator.classList.remove("urgency-high", "urgency-medium", "urgency-low", "unknown"); // Reset state
    const processedUrgency = String(urgency || "").trim().toLowerCase();

    if (processedUrgency.includes("high")) {
      urgencyIndicator.classList.add("urgency-high");
    } else if (processedUrgency.includes("medium")) {
      urgencyIndicator.classList.add("urgency-medium");
    } else if (processedUrgency.includes("low")) {
      urgencyIndicator.classList.add("urgency-low");
    } else {
      urgencyIndicator.classList.add("unknown");
    }
  }
  return;
}

/* ============================
   Compose backup and setter
   ============================ */

/**
 * Saves a backup of the current compose HTML body for undo.
 * @returns {Promise&lt;void>}
 */
composeBackupStore.saveBackup = async function () {
  try {
    const item = Office?.context?.mailbox?.item;
    if (!item || typeof item.body?.getAsync !== "function") return;
    const html = await new Promise((resolve) => {
      item.body.getAsync(Office.CoercionType.Html, (res) => {
        if (res.status === Office.AsyncResultStatus.Succeeded) resolve(res.value || "");
        else resolve("");
      });
    });
    this.lastBackup = html;
    log("Saved compose backup.");
  } catch (e) {
    console.warn("Failed saving compose backup", e);
  }
};

/**
 * Restores the last saved backup into the compose body.
 * @returns {Promise&lt;boolean>} true if restored
 */
composeBackupStore.restoreBackup = async function () {
  if (!this.lastBackup) return false;
  try {
    await setDraftBody(this.lastBackup, { createBackup: false });
    this.lastBackup = null;
    return true;
  } catch (e) {
    console.warn("Restore backup failed", e);
    return false;
  }
};

/**
 * Sets the draft HTML into the open compose editor.
 * Tries item.body.setAsync, then falls back to displayNewMessageForm.
 * @param {string} htmlContent - HTML to write into the compose body
 * @param {SetDraftOptions} [options]
 * @returns {Promise&lt;void>}
 */
async function setDraftBody(htmlContent, options = { createBackup: true }) {
  const html = sanitizeHtml(String(htmlContent || "&lt;p>&lt;/p>"));
  if (options.createBackup) await composeBackupStore.saveBackup();
  try {
    const item = Office?.context?.mailbox?.item;
    if (item &amp;&amp; typeof item.body?.setAsync === "function") {
      await new Promise((resolve, reject) => {
        item.body.setAsync(html, { coercionType: Office.CoercionType.Html }, (asyncResult) => {
          if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
            log("setDraftBody: updated compose body via setAsync.");
            resolve(true);
          } else {
            reject(asyncResult.error);
          }
        });
      });
      return;
    }
    if (typeof Office.context.mailbox.displayNewMessageForm === "function") {
      try {
        Office.context.mailbox.displayNewMessageForm({ htmlBody: html });
        log("setDraftBody: opened new compose with provided HTML as fallback.");
        return;
      } catch (e) {
        log("setDraftBody displayNewMessageForm failed: " + (e &amp;&amp; e.message));
      }
    }
    throw new Error("No supported compose APIs to set draft body in this host.");
  } catch (err) {
    showError("Could not update draft automatically. You can copy the suggested text manually.");
    log("setDraftBody failed: " + (err?.message || err));
    throw err;
  }
}

/* ============================
   Fetch helpers with timeout + retries
   ============================ */

/**
 * Performs fetch with an AbortController timeout.
 * Uses window.AbortController when available to avoid linter undefined errors.
 * @param {string} url
 * @param {RequestInit} [opts]
 * @param {number} [timeoutMs=REQUEST_TIMEOUT_MS]
 * @returns {Promise&lt;Response>}
 */
async function fetchWithTimeout(url, opts = {}, timeoutMs = REQUEST_TIMEOUT_MS) {
  // Prefer the global AbortController when available
  const AC = typeof window !== "undefined" &amp;&amp; window.AbortController ? new window.AbortController() : null;
  if (AC) {
    opts.signal = AC.signal;
  }

  const timerId = typeof window !== "undefined" &amp;&amp; window.setTimeout ? window.setTimeout(() => AC &amp;&amp; AC.abort(), timeoutMs) : null;

  try {
    const res = await fetch(url, opts);
    if (typeof window !== "undefined" &amp;&amp; window.clearTimeout &amp;&amp; timerId) window.clearTimeout(timerId);
    return res;
  } catch (err) {
    if (typeof window !== "undefined" &amp;&amp; window.clearTimeout &amp;&amp; timerId) window.clearTimeout(timerId);
    throw err;
  }
}

/**
 * Determines whether a response status is retriable.
 * @param {number} status
 * @returns {boolean}
 */
function isRetriableStatus(status) {
  return status === 429 || (status >= 500 &amp;&amp; status &lt; 600);
}

/* ============================
   Model response normalization
   ============================ */

/**
 * Normalizes various provider response shapes into { text?, functionCall? }.
 * Supports Google-style candidates and OpenAI-style choices.
 * @param {any} result
 * @returns {NormalizedResult|null}
 */
function normalizeModelResult(result) {
  const candidate = result?.candidates?.[0];
  if (candidate) {
    if (candidate.functionCall) {
      let args = candidate.functionCall.arguments || candidate.functionCall.args || candidate.functionCall.argumentsJson;
      if (typeof args === "string") {
        try {
          args = JSON.parse(args);
        } catch (parseErr) {
          log("normalizeModelResult: failed to parse functionCall args: " + (parseErr &amp;&amp; parseErr.message));
        }
      }
      return { functionCall: { name: candidate.functionCall.name, args } };
    }
    const part = candidate.content?.parts?.[0];
    if (part?.text) return { text: part.text };
    if (part?.content) return { text: part.content };
  }

  const choice = result?.choices?.[0];
  if (choice) {
    const func = choice.message?.function_call || choice.function_call;
    if (func) {
      let args = func.arguments || func.argumentsJson || func.args;
      if (typeof args === "string") {
        try {
          args = JSON.parse(args);
        } catch (parseErr) {
          log("normalizeModelResult: failed to parse function_call args: " + (parseErr &amp;&amp; parseErr.message));
        }
      }
      return { functionCall: { name: func.name, args } };
    }
    const text = choice.message?.content?.text || choice.text || "";
    if (text) return { text };
  }

  if (typeof result?.text === "string") return { text: result.text };
  return null;
}

/* ============================
   Proxy + Gemini client wrapper
   ============================ */

/**
 * Calls the server-side proxy which should call the Generative Language API.
 * Proxy URL is read from config proxy_gen_endpoint or DEFAULT_PROXY_ENDPOINT.
 * Returns normalized { text?, functionCall? }.
 *
 * @param {string} userQuery
 * @param {string} system_instruction
 * @param {CallGeminiOptions} [options]
 * @returns {Promise&lt;NormalizedResult>}
 */
async function callGeminiAPI(userQuery, system_instruction, options = {}) {
  const proxyUrl = getVar("proxy_gen_endpoint") || DEFAULT_PROXY_ENDPOINT;
  const body = { prompt: String(userQuery || ""), system: String(system_instruction || ""), ...(options.apiParams || {}) };

  const maxAttempts = options.maxAttempts || 4;
  const baseDelay = options.baseDelayMs || 1000;
  let attempt = 0;

  while (attempt &lt; maxAttempts) {
    attempt++;
    try {
      const res = await fetchWithTimeout(
        proxyUrl,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        },
        options.timeoutMs || REQUEST_TIMEOUT_MS
      );

      log(`Attempt ${attempt}: API response status is ${res.status}`);

      if (isRetriableStatus(res.status)) {
        const delay = baseDelay * Math.pow(2, attempt - 1) + Math.random() * 500;
        log(`Retriable response. Waiting ${Math.round(delay)}ms before retry.`);
        await new Promise((r) => setTimeout(r, delay));
        continue;
      }

      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`API call failed with status ${res.status}: ${txt}`);
      }

      const result = await res.json();
      if (result &amp;&amp; (result.text || result.functionCall)) return result;
      const normalized = normalizeModelResult(result);
      if (!normalized) throw new Error("Unexpected response format from proxy API.");
      log("API call successful.");
      return normalized;
    } catch (err) {
      log(`Attempt ${attempt}: an error occurred. ${err &amp;&amp; err.message}`);
      if (attempt >= maxAttempts) throw new Error(`Failed to call generative API after ${maxAttempts} attempts: ${err &amp;&amp; err.message}`);
      const backoff = baseDelay * Math.pow(2, attempt - 1) + Math.random() * 500;
      await new Promise((r) => setTimeout(r, backoff));
    }
  }
  throw new Error("callGeminiAPI exhausted retries.");
}

/**
 * Legacy wrapper for custom endpoints. Kept for compatibility.
 * @param {any} userQuery
 * @returns {Promise&lt;any>}
 */
async function callCustomEndpoint(userQuery) {
  const apiUrl = getVar("customendpoint_url");
  if (!apiUrl) throw new Error("customendpoint_url not configured.");
  const payload = { query: userQuery };
  let attempts = 0,
    maxAttempts = 5,
    baseDelay = 1000;
  while (attempts &lt; maxAttempts) {
    try {
      attempts++;
      const res = await fetchWithTimeout(
        apiUrl,
        { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) },
        REQUEST_TIMEOUT_MS
      );
      log(`Attempt ${attempts}: API response status is ${res.status}`);
      if (isRetriableStatus(res.status)) {
        const delay = baseDelay * Math.pow(2, attempts - 1) + Math.random() * 1000;
        await new Promise((r) => setTimeout(r, delay));
        continue;
      }
      if (!res.ok) {
        const errTxt = await res.text();
        throw new Error(`API call failed with status ${res.status}: ${errTxt}`);
      }
      const result = await res.json();
      if (!result) throw new Error("Invalid response format from API.");
      return result;
    } catch (err) {
      log(`Attempt ${attempts}: an error occurred. ${err &amp;&amp; err.message}`);
      if (attempts >= maxAttempts) throw err;
    }
  }
}

/* ============================
   Email helpers and compose helpers
   ============================ */

/**
 * Retrieves the email body text for the provided item.
 * @param {Office.Item} item
 * @returns {Promise&lt;string>}
 */
async function getEmailBody(item) {
  return new Promise((resolve, reject) => {
    if (item.body?.getAsync) {
      item.body.getAsync(Office.CoercionType.Text, (asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded) resolve(asyncResult.value);
        else reject(asyncResult.error);
      });
    } else resolve("");
  });
}

/**
 * Suggests a subject line derived from the item subject.
 * @param {Office.Item} item
 * @returns {string}
 */
function getSuggestedSubjectFromItem(item) {
  try {
    const subj = item?.subject?.toString ? item.subject.toString() : item?.subject || "";
    return subj ? `Re: ${subj}` : "Reply";
  } catch {
    return "Reply";
  }
}

/**
 * Tries to open a compose window and inject htmlDraft.
 * Tries displayReplyAllForm, displayReplyForm, then displayNewMessageForm as fallback.
 * @param {Office.Item} item
 * @param {string} htmlDraft
 * @param {string} fallbackSubject
 */
function openComposeWithHtml(item, htmlDraft, fallbackSubject) {
  const htmlBody = typeof htmlDraft === "string" ? htmlDraft : String(htmlDraft || "&lt;p>—&lt;/p>");
  try {
    if (typeof item.displayReplyAllForm === "function") {
      try {
        item.displayReplyAllForm({ htmlBody });
        log("Opened Reply All compose with suggested draft.");
        return;
      } catch (err) {
        log("displayReplyAllForm threw: " + (err?.message || err));
      }
    }
    if (typeof item.displayReplyForm === "function") {
      try {
        item.displayReplyForm({ htmlBody });
        log("Opened Reply compose with suggested draft.");
        return;
      } catch (err) {
        log("displayReplyForm threw: " + (err?.message || err));
      }
    }
    if (typeof Office.context.mailbox.displayNewMessageForm === "function") {
      try {
        Office.context.mailbox.displayNewMessageForm({ htmlBody, subject: fallbackSubject || getSuggestedSubjectFromItem(item) });
        log("Opened New Message compose with suggested draft.");
        return;
      } catch (err) {
        log("displayNewMessageForm threw: " + (err?.message || err));
      }
    }
    showError("Unable to open a draft in this Outlook host. Try replying manually.");
    log("No supported compose APIs available in this host.");
  } catch (err) {
    showError("Failed to open draft. See console for details.");
    console.error("Failed to open draft:", err);
  }
}

/* ============================
   Chat handling and wiring
   ============================ */

/** Guard to prevent double-send */
let sending = false;

/**
 * Handles the user's chat query, calls the generative proxy, and updates the chat UI.
 * Supports function-call responses that invoke setDraftBody for automatic draft edits.
 * @returns {Promise&lt;void>}
 */
async function handleChatQuery() {
  const input = document.getElementById("chatInput");
  const sendBtn = document.getElementById("chatSendBtn");
  if (!input || !sendBtn) return;
  const query = input.value.trim();
  if (!query || sending) return;

  sending = true;
  sendBtn.disabled = true;
  input.disabled = true;
  input.value = "";
  appendMessage(query, "user");

  appendMessage("Thinking...", "ai");
  const history = document.getElementById("chatHistory");
  const lastAiMessage = history?.lastChild;

  try {
    const chatSystemInstruction =
      getVar("chatSystemPrompt") ||
      "You are a helpful assistant. If asked to modify the draft, respond by calling the function setDraftBody with an object argument { htmlContent: '&lt;full HTML>' } and do NOT return the modified body as plain text.";

    const rawResult = await callGeminiAPI(query, chatSystemInstruction, { timeoutMs: REQUEST_TIMEOUT_MS });

    const normalized = rawResult &amp;&amp; (rawResult.text || rawResult.functionCall) ? rawResult : normalizeModelResult(rawResult);

    if (!normalized) {
      if (lastAiMessage) lastAiMessage.textContent = "Error: unexpected assistant response format.";
      return;
    }

    if (normalized.functionCall &amp;&amp; normalized.functionCall.name === "setDraftBody") {
      const args = normalized.functionCall.args || {};
      const htmlContent = args.htmlContent || args.html || args.content || "";
      if (!htmlContent) {
        if (lastAiMessage) lastAiMessage.textContent = "Assistant attempted to modify the draft but returned no content.";
      } else {
        try {
          await setDraftBody(htmlContent, { createBackup: true });
          if (lastAiMessage) lastAiMessage.textContent = "Draft updated successfully in the compose window.";
          showUndoToast();
        } catch (err) {
          if (lastAiMessage) lastAiMessage.textContent = "Assistant provided a draft; automatic update failed. See console.";
          log("handleChatQuery setDraftBody failed: " + (err &amp;&amp; err.message));
        }
      }
      return;
    }

    const replyText = normalized.text || "I couldn't generate a response.";
    if (lastAiMessage) lastAiMessage.textContent = replyText;
  } catch (err) {
    if (history?.lastChild) history.lastChild.textContent = "Error: Could not connect to the assistant.";
    console.error("Chat API error:", err);
  } finally {
    sending = false;
    sendBtn.disabled = false;
    input.disabled = false;
    input.focus();
    if (history) history.scrollTop = history.scrollHeight;
  }
}

/* ============================
   UI helpers: chat toggle &amp; undo toast
   ============================ */

/**
 * Wires the chat panel toggle header so it is keyboard accessible and updates aria-expanded correctly.
 */
function wireChatToggle() {
  const toggleBtn = document.getElementById("toggleChatBtn");
  const chatContent = document.getElementById("chatContent");
  const header = document.querySelector(".chat-header");
  if (!toggleBtn || !chatContent || !header) return;
  header.setAttribute("role", "button");
  header.tabIndex = 0;
  header.addEventListener("click", () => {
    const nowHidden = chatContent.classList.toggle("hidden");
    toggleBtn.setAttribute("aria-expanded", String(!nowHidden));
    if (!nowHidden) {
      const input = document.getElementById("chatInput");
      if (input) input.focus();
    }
  });
  header.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      header.click();
    }
  });
}

/**
 * Shows a small undo toast after an automatic draft update. Auto-hides after 30s.
 * Clicking Undo attempts to restore the previous draft.
 */
function showUndoToast() {
  let toast = document.getElementById("undoToast");
  if (!toast) {
    toast = document.createElement("div");
    toast.id = "undoToast";
    toast.className = "card";
    toast.style.position = "fixed";
    toast.style.right = "16px";
    toast.style.bottom = "16px";
    toast.style.zIndex = 9999;
    const text = document.createElement("div");
    text.textContent = "Draft updated. ";
    const undoBtn = document.createElement("button");
    undoBtn.textContent = "Undo";
    undoBtn.className = "primary";
    undoBtn.addEventListener("click", async () => {
      const ok = await composeBackupStore.restoreBackup();
      if (ok) {
        showError("Draft restored.");
      } else {
        showError("No backup available.");
      }
      cleanup();
    });
    const cleanup = () => {
      if (toast &amp;&amp; toast.parentNode) toast.parentNode.removeChild(toast);
    };
    toast.appendChild(text);
    toast.appendChild(undoBtn);
    document.body.appendChild(toast);
    setTimeout(cleanup, 30000);
  }
}

/* ============================
   DOM wiring (single init)
   ============================ */

document.addEventListener("DOMContentLoaded", () => {
  registerThemeChangeHandler();

  // Quick Reply guard - enabled by onReady when item is present
  const btnQuickReply = document.getElementById("btnQuickReply");
  if (btnQuickReply) btnQuickReply.disabled = true;

  // Info button: open configured help URL or show inline info window
  const infoBtn = document.querySelector(".infoBtn");
  if (infoBtn) {
    infoBtn.addEventListener("click", () => {
      try {
        const helpUrl = getVar("helpUrl");
        if (helpUrl) {
          window.open(helpUrl, "_blank", "noopener,noreferrer");
          log(`Opened help link: ${helpUrl}`);
        } else {
          const infoWindow = window.open("", "Info", "width=400,height=250,menubar=no,toolbar=no,location=no");
          if (infoWindow) {
            infoWindow.document.write(
              "&lt;!doctype html>&lt;html>&lt;head>&lt;meta charset='utf-8'>&lt;title>About CommsAssist&lt;/title>&lt;/head>" +
                "&lt;body style='font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;padding:1em;'>" +
                "&lt;h2>CommsAssist&lt;/h2>" +
                "&lt;p>Hello! I am your AI assistant for managing email communications.&lt;/p>" +
                "&lt;p>I can analyze sentiment, intention, and urgency of incoming emails, and draft replies for you.&lt;/p>" +
                "&lt;p>Please select an email to get started.&lt;/p>" +
                "&lt;/body>&lt;/html>"
            );
            infoWindow.document.close();
          }
        }
      } catch (err) {
        console.error("Failed to open help link:", err);
        showError("Failed to open help link.");
      }
    });
  }

  wireChatToggle();

  const chatSendBtn = document.getElementById("chatSendBtn");
  const chatInput = document.getElementById("chatInput");
  if (chatSendBtn) chatSendBtn.addEventListener("click", handleChatQuery);
  if (chatInput) {
    chatInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" &amp;&amp; !e.shiftKey) {
        e.preventDefault();
        handleChatQuery();
      }
    });
  }
});

/* ============================
   Main Office onReady flow
   ============================ */

/**
 * Main entry point for the Office Add-in. Loads config, applies theme, analyzes message in read mode,
 * wires Quick Reply to generate drafts and supports function-call responses to auto-update compose.
 *
 * @param {Office.OnReadyInfo} info
 */
Office.onReady(async (info) => {
  log("Office.js is ready.");
  const configUrl = "config/config.json";

  try {
    await loadConfig(configUrl);
    log("Configuration loaded successfully.");
  } catch (error) {
    console.error(`Failed to load configuration: ${error.message}`);
    log(`Failed to load configuration: ${error.message}`);
  }

  if (info) log(`Add-in is running in ${info.host} on ${info.platform}.`);

  const theme = Office.context.officeTheme;
  if (theme) applyOfficeThemeVars(theme);

  const item = Office.context?.mailbox?.item;
  const helpdeskPrompt = getVar("helpdeskPrompt");
  const sentimentPrompt = getVar("sentimentPrompt");
  const urgencyPrompt = getVar("urgencyPrompt");
  const intentionPrompt = getVar("intentionPrompt");
  const customEndpointUrl = getVar("customendpoint_url");

  if (!item) {
    log("No mail item found. Add-in may be running in an unsupported context.");
    const sc = document.getElementById("sentimentContent");
    if (sc) sc.classList.add("hidden");
    const quickBtn = document.getElementById("btnQuickReply");
    if (quickBtn) quickBtn.disabled = true;
    const rc = document.getElementById("responseContainer");
    if (rc) rc.textContent = "This add-in only works with email messages.";
    return;
  }

  log(`Item type: ${item.itemType}`);

  const isReadMode = item.itemType === Office.MailboxEnums.ItemType.Message;
  const isComposeMode = item.itemType === Office.MailboxEnums.ItemType.MessageCompose;

  if (isReadMode) {
    log("In READ mode.");
    const sc = document.getElementById("sentimentContent");
    if (sc) sc.classList.remove("hidden");
    const quickBtn = document.getElementById("btnQuickReply");
    if (quickBtn) quickBtn.disabled = false;

    const emailBody = (await getEmailBody(item)).trim();
    const rc = document.getElementById("responseContainer");
    if (rc) rc.innerHTML = "Analyzing email content, please wait...";

    let name = "";
    if (item.from) name = item.from.displayName || item.from.emailAddress || "";

    try {
      if (customEndpointUrl !== "") {
        const query = { fromEmailAddress: name, subject: item.subject ? item.subject : "Unknown", body: emailBody };
        const responseData = await callCustomEndpoint(query);
        log(`Call response: ${JSON.stringify(responseData)}`);
        let sentiment = responseData?.response?.metadata?.email_sentiment ?? "Unknown";
        let urgency = responseData?.response?.metadata?.email_urgency ?? "Unknown";
        let intention = responseData?.response?.metadata?.email_intention ?? "Unknown";
        draft = removeHtmlFences(responseData?.response?.answer?.email_draft ?? "");
        if (rc) rc.innerHTML = "Analysis complete. Please click 'Quick Reply' to generate a draft.";
        setMetaData(sentiment, urgency, intention);
      } else {
        let sentiment = "Unknown",
          urgency = "Unknown",
          intention = "Unknown";
        try {
          const prompt = `From: ${name}\nBody: ${emailBody}`;
          sentiment = await callGeminiAPI(prompt, sentimentPrompt);
          log(`Sentiment analysis result: ${sentiment}`);
        } catch (err) {
          log(`Error analyzing sentiment: ${err.message}`);
        }
        try {
          const prompt = `From: ${name}\nBody: ${emailBody}`;
          urgency = await callGeminiAPI(prompt, urgencyPrompt);
          log(`Urgency analysis result: ${urgency}`);
        } catch (err) {
          log(`Error analyzing urgency: ${err.message}`);
        }
        try {
          const prompt = `From: ${name}\nBody: ${emailBody}`;
          intention = await callGeminiAPI(prompt, intentionPrompt);
          log(`Intention analysis result: ${intention}`);
        } catch (err) {
          log(`Error analyzing intention: ${err.message}`);
        }

        if (rc) rc.innerHTML = "Analysis complete. Please click 'Quick Reply' to generate a draft.";
        setMetaData(sentiment, urgency, intention);
      }
    } catch (err) {
      log(`Error calling endpoint: ${err.message}`);
      console.error(`Error calling endpoint: ${err.message}`);
      showError("Analysis failed. See console for details.");
    }

    // Quick Reply behavior uses callGeminiAPI and supports function-call returns that update compose
    const quickReplyBtn = document.getElementById("btnQuickReply");
    if (quickReplyBtn) {
      quickReplyBtn.addEventListener("click", async () => {
        quickReplyBtn.disabled = true;
        const rc2 = document.getElementById("responseContainer");
        if (rc2) rc2.textContent = "Generating draft...";

        try {
          if (customEndpointUrl === "") {
            const prompt = `From: ${name}\nBody: ${emailBody}`;
            const result = await callGeminiAPI(prompt, helpdeskPrompt, { timeoutMs: REQUEST_TIMEOUT_MS });
            const normalized = result &amp;&amp; (result.text || result.functionCall) ? result : normalizeModelResult(result);

            if (normalized?.functionCall &amp;&amp; normalized.functionCall.name === "setDraftBody") {
              const html = normalized.functionCall.args?.htmlContent || normalized.functionCall.args?.html || "";
              if (html) {
                await setDraftBody(html, { createBackup: true });
                draft = html;
                if (rc2) rc2.textContent = "Draft generated and inserted into compose window.";
                showUndoToast();
              } else throw new Error("functionCall returned no html content");
            } else if (normalized?.text) {
              draft = removeHtmlFences(normalized.text);
              const cleaned = sanitizeHtml(draft);
              openComposeWithHtml(item, cleaned, getSuggestedSubjectFromItem(item));
              if (rc2) rc2.textContent = "Draft generated successfully. Opening compose window...";
            } else throw new Error("Invalid response from generator");
          } else {
            // Legacy custom endpoint flow might already return HTML draft
            const response = await callCustomEndpoint({ fromEmailAddress: name, subject: item.subject || "Unknown", body: emailBody });
            draft = removeHtmlFences(response?.response?.answer?.email_draft || "");
            const cleaned = sanitizeHtml(draft);
            openComposeWithHtml(item, cleaned, getSuggestedSubjectFromItem(item));
            if (rc2) rc2.textContent = "Draft generated successfully. Opening compose window...";
          }
        } catch (err) {
          draft = "&lt;html>&lt;body>&lt;p>Error generating draft. Please try again.&lt;/p>&lt;/body>&lt;/html>";
          log(`Error generating draft: ${err &amp;&amp; err.message}`);
          console.error(`Error generating draft: ${err}`);
          if (document.getElementById("responseContainer"))
            document.getElementById("responseContainer").textContent = "Error generating draft. Please try again.";
        } finally {
          quickReplyBtn.disabled = false;
        }
      });
    }
  } else if (isComposeMode) {
    log("In COMPOSE mode.");
    const sc = document.getElementById("sentimentContent");
    if (sc) sc.classList.add("hidden");
    const quickBtn = document.getElementById("btnQuickReply");
    if (quickBtn) quickBtn.disabled = true;
    const rc = document.getElementById("responseContainer");
    if (rc) rc.innerHTML = "This functionality is not available in compose mode.";
  } else {
    log("In an unsupported mode.");
    const sc = document.getElementById("sentimentContent");
    if (sc) sc.classList.add("hidden");
    const quickBtn = document.getElementById("btnQuickReply");
    if (quickBtn) quickBtn.disabled = true;
    const rc = document.getElementById("responseContainer");
    if (rc) rc.textContent = "This add-in only works with email messages.";
  }
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#appendMessage">appendMessage</a></li><li><a href="global.html#applyOfficeThemeVars">applyOfficeThemeVars</a></li><li><a href="global.html#callCustomEndpoint">callCustomEndpoint</a></li><li><a href="global.html#callGeminiAPI">callGeminiAPI</a></li><li><a href="global.html#capHistory">capHistory</a></li><li><a href="global.html#composeBackupStore">composeBackupStore</a></li><li><a href="global.html#configMap">configMap</a></li><li><a href="global.html#draft">draft</a></li><li><a href="global.html#fetchWithTimeout">fetchWithTimeout</a></li><li><a href="global.html#getEmailBody">getEmailBody</a></li><li><a href="global.html#getSuggestedSubjectFromItem">getSuggestedSubjectFromItem</a></li><li><a href="global.html#getVar">getVar</a></li><li><a href="global.html#handleChatQuery">handleChatQuery</a></li><li><a href="global.html#isRetriableStatus">isRetriableStatus</a></li><li><a href="global.html#loadConfig">loadConfig</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#normalizeModelResult">normalizeModelResult</a></li><li><a href="global.html#openComposeWithHtml">openComposeWithHtml</a></li><li><a href="global.html#registerThemeChangeHandler">registerThemeChangeHandler</a></li><li><a href="global.html#removeHtmlFences">removeHtmlFences</a></li><li><a href="global.html#sanitizeHtml">sanitizeHtml</a></li><li><a href="global.html#sending">sending</a></li><li><a href="global.html#setDraftBody">setDraftBody</a></li><li><a href="global.html#setMetaData">setMetaData</a></li><li><a href="global.html#showError">showError</a></li><li><a href="global.html#showUndoToast">showUndoToast</a></li><li><a href="global.html#wireChatToggle">wireChatToggle</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Oct 01 2025 15:37:41 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
