<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: pane.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: pane.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Logs a message to the console with a [DEBUG] prefix.
 * @param {string} message - The message to log.
 */
function log(message) {
  console.log(`[DEBUG] ${message}`);
}

// A private variable to hold our configuration data.
// A Map is used for efficient key-value pair storage and retrieval.
let configMap = new Map();

/**
 * Fetches the config.json file from the specified URL,
 * parses the JSON, and loads the key-value pairs into a map.
 * This is an asynchronous operation.
 * @param {string} url The URL of the config.json file.
 * @returns {Promise&lt;void>} A promise that resolves when the config is loaded.
 */
/**
 * Fetches the config.json file from the specified URL,
 * parses the JSON, and loads the key-value pairs into a map.
 * This is an asynchronous operation.
 * @param {string} url The URL of the config.json file.
 * @returns {Promise&lt;void>} A promise that resolves when the config is loaded.
 */
async function loadConfig(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const parsedData = await response.json();
 
    // Unpack the key-value pairs into the global map
    for (const key in parsedData) {
      configMap.set(key, parsedData[key]);
    }
  } catch (e) {
    console.error(`Failed to load configuration: ${e.message}`);
    throw e;
  }
}

/**
 * Retrieves a value from the configuration map using its key.
 * @param {string} key The key to look up in the config.
 * @returns {*} The value associated with the key, or undefined if the key is not found.
 */
function getVar(key) {
  if (configMap.size !== 0) {
    const value = configMap.get(key);
    // If the value is an array, join its elements with a newline character.
    if (Array.isArray(value)) {
        return value.join(String.fromCharCode(10));
    }
    return value;
  }
  return "";
}

/**
 * Updates the document body styles based on the Office theme.
 * @param {Object} theme - The Office theme object.
 */
function updateThemeStyles(theme) {
  if (theme) {
    document.documentElement.style.setProperty("--bg-color", theme.bodyBackgroundColor);
    document.documentElement.style.setProperty("--text-color", theme.bodyForegroundColor);
  }
}

/**
 * Registers the Office theme change event handler.
 */
function registerThemeChangeHandler() {
  const mailbox = Office.context?.mailbox;
  if (mailbox) {
    mailbox.addHandlerAsync(
      Office.EventType.OfficeThemeChanged,
      (eventArgs) => {
        const theme = eventArgs.officeTheme;
        updateThemeStyles(theme);
      },
      (result) => {
        if (result.status === Office.AsyncResultStatus.Failed) {
          console.error("Failed to register theme change handler:", result.error.message);
        } else {
          log("Theme change handler registered successfully.");
        }
      }
    );
  }
}

/**
 * Calls the Gemini API to generate a response.
 * Includes a retry mechanism with exponential backoff for rate limit errors.
 * @param {string} userQuery - The user's query to send to the API.
 * @param {string} system_instruction - The system instruction for the API.
 * @returns {Promise&lt;string>} A promise that resolves with the generated text.
 */
async function callGeminiAPI(userQuery, system_instruction) {
  const apiKey = getVar("google_api_key"); // Replace with your actual API key or use a secure method to store it
  if (!apiKey) {
    throw new Error("GEMINI_API_KEY is not set in environment variables.");
  }
  const apiUrl = `${getVar("endpoint_url")}${apiKey}`;
  const payload = {
    contents: [
      {
        parts: [
          {
            text: userQuery,
          },
        ],
      },
    ],
    tools: [
      {
        google_search: {},
      },
    ],
    systemInstruction: {
      parts: [
        {
          text: system_instruction,
        },
      ],
    },
  };

  let attempts = 0;
  const maxAttempts = 5;
  const baseDelay = 1000;

  while (attempts &lt; maxAttempts) {
    try {
      const response = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      });
      log(`Attempt ${attempts + 1}: API response status is ${response.status}`);

      // Handles rate limiting with exponential backoff
      if (response.status === 429) {
        const delay = baseDelay * Math.pow(2, attempts) + Math.random() * 1000;
        attempts++;
        log(`Rate limit exceeded. Retrying in ${delay}ms.`);
        await new Promise((res) => setTimeout(res, delay));
        continue;
      }

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API call failed with status ${response.status}: ${errorText}`);
      }

      const result = await response.json();
      const candidate = result.candidates?.[0];

      // Checks for a valid response format and returns the generated text
      if (candidate &amp;&amp; candidate.content?.parts?.[0]?.text) {
        log("API call successful.");
        return candidate.content.parts[0].text;
      } else {
        throw new Error("Invalid response format from API.");
      }
    } catch (error) {
      attempts++;
      log(`Attempt ${attempts}: an error occurred. ${error.message}`);
      if (attempts >= maxAttempts) {
        throw new Error(`Failed to call Gemini API after ${maxAttempts} attempts.`);
      }
    }
  }
}

/**
 * The main entry point for the Office Add-in.
 * This function runs when the Office document is ready.
 */
Office.onReady(async (info) => {
  log("Office.js is ready.");
  const configUrl = "https://localhost:3000/config/config.json";

  // Load the config file from the specified URL
  try {
    await loadConfig(configUrl);
    log("Configuration loaded successfully.");
  } catch (error) {
    console.error(`Failed to load configuration: ${error.message}`);
    log(`Failed to load configuration: ${error.message}`);
  }

  if (info) {
    log(`Add-in is running in ${info.host} on ${info.platform}.`);
  }

  // Set initial theme
  const theme = Office.context.officeTheme;
  if (theme) {
    updateThemeStyles(theme);
  }

  // Register theme change handler after onReady
  registerThemeChangeHandler();

  const item = Office.context?.mailbox?.item;

  const helpdeskPrompt = getVar("helpdeskPrompt");
  const sentimentPrompt = getVar("sentimentPrompt");
  const urgencyPrompt = getVar("urgencyPrompt");
  const intentionPrompt = getVar("intentionPrompt");

  if (!item) {
    log("No mail item found. Add-in may be running in an unsupported context.");
    // Hides the main content and disables buttons
    document.getElementById("readModeContent").classList.add("hidden");
    document.getElementById("sentimentContent").classList.add("hidden");
    document.getElementById("btnQuickReply").disabled = true;
    document.getElementById("btnGenerateDraft").disabled = true;
    // Displays a message to the user
    document.getElementById("responseContainer").textContent =
      "This add-in only works with email messages.";
    return; // Stop execution if no item is available
  }

  log(`Item type: ${item.itemType}`);

  // Checks the mode (Read or Compose) of the mail item
  const isReadMode = item.itemType === Office.MailboxEnums.ItemType.Message;
  const isComposeMode = item.itemType === Office.MailboxEnums.ItemType.MessageCompose;

  // Declaring draft variable here to be available to all listeners
  let draft = "";

  if (isReadMode) {
    log("In READ mode.");
    // Shows the read mode UI and enables the buttons
    document.getElementById("readModeContent").classList.remove("hidden");
    document.getElementById("sentimentContent").classList.remove("hidden");
    document.getElementById("btnQuickReply").disabled = false;
    document.getElementById("btnGenerateDraft").disabled = false;

    // Populates the UI with email subject and sender information
    if (item.subject) {
      document.getElementById("subj").textContent = item.subject;
    }

    if (item.from) {
      document.getElementById("from").textContent = item.from.displayName || item.from.emailAddress;
      log(`From retrieved: ${item.from.emailAddress}`);
    }

    // Retrieves the email body asynchronously and populates the preview
    if (item.body?.getAsync) {
      item.body.getAsync(Office.CoercionType.Text, (res) => {
        const txt = (res.value || "").trim();
        document.getElementById("preview").textContent = txt;
      });
    }

    try {
      // Retrieves additional email metadata asynchronously
      let sentiment = "Unknown";
      let urgency = "Unknown";
      let intention = "Unknown";

      // Calls the Gemini API to analyze sentiment
      try {
        const prompt = `
          From: ${document.getElementById("from").textContent}
          Body: ${document.getElementById("preview").textContent}`;
        sentiment = await callGeminiAPI(prompt, sentimentPrompt);
        log(`Sentiment analysis result: ${sentiment}`);
      } catch (error) {
        log(`Error analyzing sentiment: ${error.message}`);
      }
      // Calls the Gemini API to analyze urgency
      try {
        const prompt = `
          From: ${document.getElementById("from").textContent}
          Body: ${document.getElementById("preview").textContent}`;
        urgency = await callGeminiAPI(prompt, urgencyPrompt);
        log(`Urgency analysis result: ${urgency}`);
      } catch (error) {
        console.error(`Error analyzing urgency: ${error.message}`);
        log(`Error analyzing urgency: ${error.message}`);
      }
      // Calls the Gemini API to analyze intention
      try {
        const prompt = `
          From: ${document.getElementById("from").textContent}
          Body: ${document.getElementById("preview").textContent}`;
        intention = await callGeminiAPI(prompt, intentionPrompt);
        log(`Intention analysis result: ${intention}`);
      } catch (error) {
        console.error(`Error analyzing intention: ${error.message}`);
        log(`Error analyzing intention: ${error.message}`);
      }
      // Logs the retrieved metadata
      log(`Email Metadata - Sentiment: ${sentiment}, Urgency: ${urgency}, Intention: ${intention}`);

      // Get the indicator element
      const urgencyIndicator = document.getElementById("urgencyIndicator");

      // Updates the UI with the retrieved metadata
      document.getElementById("sentiment").textContent = sentiment;
      document.getElementById("urgency").textContent = urgency;
      document.getElementById("intention").textContent = intention;

      // Update urgency indicator color
      if (urgencyIndicator) {
        urgencyIndicator.classList.remove("urgency-high", "urgency-medium", "urgency-low"); // Reset state
        const processedUrgency = urgency.trim().toLowerCase();

        if (processedUrgency.includes("high")) {
          urgencyIndicator.classList.add("urgency-high");
        } else if (processedUrgency.includes("medium")) {
          urgencyIndicator.classList.add("urgency-medium");
        } else if (processedUrgency.includes("low")) {
          urgencyIndicator.classList.add("urgency-low");
        }
      }
    } catch (error) {
      console.error(`Error retrieving additional email metadata: ${error.message}`);
      log(`Error retrieving additional email metadata: ${error.message}`);
    }

    // Event listener for the 'Quick Reply' button
    document.getElementById("btnQuickReply").addEventListener("click", async () => {
      // Disables the button and shows a loading message
      document.getElementById("btnQuickReply").disabled = true;
      document.getElementById("responseContainer").innerHTML = "Generating draft...";

      try {
        // Calls the Gemini API to generate the draft
        const prompt = `
          From: ${document.getElementById("from").textContent}
          Body: ${document.getElementById("preview").textContent}`;
        const generatedText = await callGeminiAPI(prompt, helpdeskPrompt);

        draft = generatedText;
        log("Draft generated successfully.");
      } catch (error) {
        draft = "&lt;html>&lt;body>&lt;p>Error generating draft. Please try again.&lt;/p>&lt;/body>&lt;/html>";
        log(`Error generating draft: ${error.message}`);
        console.error(`Error generating draft: ${error.message}`);
      } finally {
        // Re-enables the button
        document.getElementById("btnQuickReply").disabled = false;
        document.getElementById("responseContainer").innerHTML = "Draft generated successfully.";
      }
      // Displays the generated draft in a reply form with HTML coercion
      if (item.displayReplyAllForm) {
        item.displayReplyAllForm(draft, {
          coercionType: Office.CoercionType.Html,
        });
      }
    });

    // Event listener for the 'Generate Draft' button
    document.getElementById("btnGenerateDraft").addEventListener("click", async () => {
      // Disables the button and shows a loading message
      document.getElementById("btnGenerateDraft").disabled = true;
      document.getElementById("responseContainer").innerHTML = "Generating draft...";

      try {
        const prompt = `
          From: ${document.getElementById("from").textContent}
          Body: ${document.getElementById("preview").textContent}`;
        // Calls the Gemini API to generate the draft
        const generatedText = await callGeminiAPI(prompt, helpdeskPrompt);
        draft = generatedText;
        // Displays the generated draft in the response container
        document.getElementById("responseContainer").innerHTML = draft;
        log("Draft generated successfully.");
      } catch (error) {
        // Displays an error message on failure
        document.getElementById("responseContainer").innerHTML =
          "Error: Failed to generate a draft.";
        log(`Error generating draft: ${error.message}`);
        console.error(`Error generating draft: ${error.message}`);
      } finally {
        // Re-enables the button
        document.getElementById("btnGenerateDraft").disabled = false;
      }
    });
  } else if (isComposeMode) {
    log("In COMPOSE mode.");
    // Hides the main content and disables buttons for compose mode
    document.getElementById("readModeContent").classList.add("hidden");
    document.getElementById("sentimentContent").classList.add("hidden");
    document.getElementById("btnQuickReply").disabled = true;
    document.getElementById("btnGenerateDraft").disabled = true;
    document.getElementById("responseContainer").innerHTML =
      "This functionality is not available in compose mode.";
  } else {
    log("In an unsupported mode.");
    // Hides the main content and disables buttons for unsupported modes
    document.getElementById("readModeContent").classList.add("hidden");
    document.getElementById("sentimentContent").classList.add("hidden");
    document.getElementById("btnQuickReply").disabled = true;
    document.getElementById("btnGenerateDraft").disabled = true;
    document.getElementById("responseContainer").innerHTML =
      "This add-in only works with email messages.";
  }
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#callGeminiAPI">callGeminiAPI</a></li><li><a href="global.html#getVar">getVar</a></li><li><a href="global.html#loadConfig">loadConfig</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#registerThemeChangeHandler">registerThemeChangeHandler</a></li><li><a href="global.html#updateThemeStyles">updateThemeStyles</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Sep 09 2025 11:51:28 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
