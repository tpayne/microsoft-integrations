<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: pane.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: pane.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Logs a message to the console with a [DEBUG] prefix.
 * @param {string} message - The message to log.
 */
function log(message) {
  console.log(`[DEBUG] ${message}`);
}

/**
 * The main entry point for the Office Add-in.
 * This function runs when the Office document is ready.
 */
Office.onReady(async () => {
  log("Office.js is ready.");
  const item = Office.context?.mailbox?.item;

  const helpdeskPrompt = `You are an automated IT helpdesk email chatbot for a corporate IT support desk. 
                          You refer to yourself as HelpBot. You know everything about common IT problems. 
                          Respond as if you were an IT helpdesk professional, keeping calm but empathizing with the sentiment 
                          of the message used. Do not get patronizing however. Shape your response as if talking to a 
                          semi-IT literate person using an email format. You do not know anything about topics other 
                          than common IT problems. You are truthful and never lie. Never make up facts and 
                          if you are not 100% sure reply with why you cannot answer in a truthful way. 
                          If you can, cite references that can be used to further diagnose or help fix the issue. 
                          Return the full email text only, do not return any other text.
                          Ensure that the email is formatted correctly to display to a user in a reply window and use markdown
                          with headings, paragraphs, newlines, bullet points, and bold text where appropriate to enhance readability. 
                          Use the format of the user's email to guide your response style.
                          Write the response in paragraphs with new lines between paragraphs, so they are easy to read.
                          If you need further information, explain what you need and why in clear steps.`;
  const sentimentPrompt = `You are an expert sentiment analysis.
                           You will be provided with an email body.
                           Your task is to analyze the sentiment of the email and respond with one of the following labels only:
                           "Positive", "Neutral", "Negative".
                           1. "Positive" sentiment is when the email expresses happiness, satisfaction, gratitude, or any other positive emotion.
                           2. "Neutral" sentiment is when the email is factual, objective, or does not express any strong emotion.
                           3. "Negative" sentiment is when the email expresses dissatisfaction, frustration, anger, or any other negative emotion.
                           The sentiment is based on the overall tone and emotion conveyed in the email body.
                           The default is "Neutral" unless the email explicitly indicates a positive or negative sentiment.
                           Do not provide any additional text or explanation, just the label.`;
  const urgencyPrompt   = `You are an expert at urgency analysis.
                           You will be provided with an email body.
                           Your task is to analyze the urgency of the email and respond with one of the following labels only:
                           "High", "Medium", "Low".
                           1. "High" urgency is when the email indicates an immediate need for response or action, such as emergencies, critical issues, or tight deadlines.
                           2. "Medium" urgency is when the email indicates a need for response or action within a reasonable timeframe, such as upcoming deadlines or important but not critical issues.
                           3. "Low" urgency is when the email indicates no immediate need for response or action, such as general information, casual updates, or non-urgent matters.
                           The urgency is based on how quickly the sender needs a response, action or how bad the issue sounds.
                           The default is "Low" unless the email explicitly indicates a higher urgency, a deadline or severe issue.
                           Do not provide any additional text or explanation, just the label.`;
  const intentionPrompt = `You are an expert at intention analysis.
                           You will be provided with an email body.
                           Your task is to analyze the intention of the email and respond with one of the following labels only:
                           "Requesting Help", "Providing Information", "IT Issue", "HR Query", "Customer Request", "Other".
                           1. "Requesting Help" is when the sender is asking for assistance or support.
                           2. "Providing Information" is when the sender is sharing details, updates, or news.
                           3. "IT Issue" is when the sender is reporting a technical problem or seeking technical support.
                           4. "HR Query" is when the sender is asking about human resources-related topics such as policies, benefits, or employment issues.
                           5. "Customer Request" is when the sender is a customer asking for service, support, or information related to products or services.
                           The intention is based on the main purpose of the email.
                           If the email does not roughly fit into one of these categories, respond with "Other". You can do a fuzzy match if needed.
                           Do not provide any additional text or explanation, just the label.`;

  if (!item) {
    log("No mail item found. Add-in may be running in an unsupported context.");
    // Hides the main content and disables buttons
    document.getElementById("read_mode_content").classList.add("hidden");    
    document.getElementById("sentiment_content").classList.add("hidden");
    document.getElementById("btn_quick_reply").disabled = true;
    document.getElementById("btn_generate_draft").disabled = true;
    // Displays a message to the user
    document.getElementById("response_container").textContent =
      "This add-in only works with email messages.";
    return; // Stop execution if no item is available
  }

  log(`Item type: ${item.itemType}`);

  // Checks the mode (Read or Compose) of the mail item
  const isReadMode = item.itemType === Office.MailboxEnums.ItemType.Message;
  const isComposeMode =
    item.itemType === Office.MailboxEnums.ItemType.MessageCompose;

  // Declaring draft variable here to be available to all listeners
  let draft = '';
  
  if (isReadMode) {
    log("In READ mode.");
    // Shows the read mode UI and enables the buttons
    document.getElementById("read_mode_content").classList.remove("hidden");
    document.getElementById("sentiment_content").classList.remove("hidden");
    document.getElementById("btn_quick_reply").disabled = false;
    document.getElementById("btn_generate_draft").disabled = false;

    // Populates the UI with email subject and sender information
    if (item.subject) {
      document.getElementById("subj").textContent = item.subject;
    }

    if (item.from) {
      document.getElementById("from").textContent =
        item.from.displayName || item.from.emailAddress;
      log(`From retrieved: ${item.from.emailAddress}`);
    }

    // Retrieves the email body asynchronously and populates the preview
    if (item.body?.getAsync) {
      item.body.getAsync(Office.CoercionType.Text, (res) => {
        const txt = (res.value || "").trim();
        document.getElementById("preview").textContent = txt;
      });
    }

    try {
      // Retrieves additional email metadata asynchronously
      let sentiment = "Unknown";
      let urgency = "Unknown";
      let intention = "Unknown";

      // Calls the Gemini API to analyze sentiment
      try {
        const prompt = `
          From: ${document.getElementById("from").textContent}
          Body: ${document.getElementById("preview").textContent}`;
        sentiment = await callGeminiAPI(prompt, sentimentPrompt);
        log(`Sentiment analysis result: ${sentiment}`);
      } catch (error) {
        log(`Error analyzing sentiment: ${error.message}`);
      }
      // Calls the Gemini API to analyze urgency
      try {
        const prompt = `
          From: ${document.getElementById("from").textContent}
          Body: ${document.getElementById("preview").textContent}`;
        urgency = await callGeminiAPI(prompt, urgencyPrompt);
        log(`Urgency analysis result: ${urgency}`);
      } catch (error) {
        log(`Error analyzing urgency: ${error.message}`);
      }
      // Calls the Gemini API to analyze intention
      try {
        const prompt = `
          From: ${document.getElementById("from").textContent}
          Body: ${document.getElementById("preview").textContent}`;
        intention = await callGeminiAPI(prompt, intentionPrompt);
        log(`Intention analysis result: ${intention}`);
      } catch (error) {
        log(`Error analyzing intention: ${error.message}`);
      }
      // Logs the retrieved metadata
      log(`Email Metadata - Sentiment: ${sentiment}, Urgency: ${urgency}, Intention: ${intention}`);
      // Updates the UI with the retrieved metadata
      document.getElementById("sentiment").textContent = sentiment;
      document.getElementById("urgency").textContent = urgency;
      document.getElementById("intention").textContent = intention;
    } catch (error) {
      log(`Error retrieving additional email metadata: ${error.message}`);
    }
    
      // Event listener for the 'Quick Reply' button
    document.getElementById("btn_quick_reply").addEventListener("click", async () => {
      try {
        // Calls the Gemini API to generate the draft
        const prompt = `
          From: ${document.getElementById("from").textContent}
          Body: ${document.getElementById("preview").textContent}`;
        const generatedText = await callGeminiAPI(prompt, helpdeskPrompt);
        draft = generatedText;
      } catch (error) {
        draft = "Error generating draft. Please try again.";
        log(`Error generating draft: ${error.message}`);
      }
      // Displays the generated draft in a reply form
      if (item.displayReplyAllForm) {
        item.displayReplyAllForm(draft);
      }
    });

    // Event listener for the 'Generate Draft' button
    document.getElementById("btn_generate_draft").addEventListener("click", async () => {
      // Disables the button and shows a loading message
      document.getElementById("btn_generate_draft").disabled = true;
      document.getElementById("response_container").textContent = "Generating draft...";

      try {
        const prompt = `
          From: ${document.getElementById("from").textContent}
          Body: ${document.getElementById("preview").textContent}`;
        // Calls the Gemini API to generate the draft
        const generatedText = await callGeminiAPI(prompt, helpdeskPrompt);
        draft = generatedText;
        // Displays the generated draft in the response container
        document.getElementById("response_container").textContent = draft;
        log("Draft generated successfully.");
      } catch (error) {
        // Displays an error message on failure
        document.getElementById("response_container").textContent = "Error: Failed to generate a draft.";
        log(`Error generating draft: ${error.message}`);
      } finally {
        // Re-enables the button
        document.getElementById("btn_generate_draft").disabled = false;
      }
    });

  } else if (isComposeMode) {
    log("In COMPOSE mode.");
    // Hides the main content and disables buttons for compose mode
    document.getElementById("read_mode_content").classList.add("hidden");
    document.getElementById("sentiment_content").classList.add("hidden");
    document.getElementById("btn_quick_reply").disabled = true;
    document.getElementById("btn_generate_draft").disabled = true;
    document.getElementById("response_container").textContent =
      "This functionality is not available in compose mode.";
  } else {
    log("In an unsupported mode.");
    // Hides the main content and disables buttons for unsupported modes
    document.getElementById("read_mode_content").classList.add("hidden");
    document.getElementById("sentiment_content").classList.add("hidden");
    document.getElementById("btn_quick_reply").disabled = true;
    document.getElementById("btn_generate_draft").disabled = true;
    document.getElementById("response_container").textContent =
      "This add-in only works with email messages.";
  }
  
  /**
   * Calls the Gemini API to generate a response.
   * Includes a retry mechanism with exponential backoff for rate limit errors.
   * @param {string} userQuery - The user's query to send to the API.
   * @param {string} system_instruction - The system instruction for the API.
   * @returns {Promise&lt;string>} A promise that resolves with the generated text.
   */
  async function callGeminiAPI(userQuery, system_instruction) {
    const apiKey = "&lt;ENTERYOUCODEHERE>"; // Replace with your actual API key or use a secure method to store it
    if (!apiKey) {
      throw new Error("GEMINI_API_KEY is not set in environment variables.");
    }
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
    const payload = {
      contents: [{ parts: [{ text: userQuery }] }],
      tools: [{ "google_search": {} }],
      systemInstruction: { parts: [{ text: system_instruction }] },
    };

    let attempts = 0;
    const maxAttempts = 5;
    const baseDelay = 1000;

    while (attempts &lt; maxAttempts) {
      try {
        const response = await fetch(apiUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        log(`Attempt ${attempts + 1}: API response status is ${response.status}`);

        // Handles rate limiting with exponential backoff
        if (response.status === 429) {
          const delay = baseDelay * Math.pow(2, attempts) + Math.random() * 1000;
          attempts++;
          log(`Rate limit exceeded. Retrying in ${delay}ms.`);
          await new Promise((res) => setTimeout(res, delay));
          continue;
        }

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(
            `API call failed with status ${response.status}: ${errorText}`
          );
        }

        const result = await response.json();
        const candidate = result.candidates?.[0];

        // Checks for a valid response format and returns the generated text
        if (candidate &amp;&amp; candidate.content?.parts?.[0]?.text) {
          log("API call successful.");
          return candidate.content.parts[0].text;
        } else {
          throw new Error("Invalid response format from API.");
        }
      } catch (error) {
        attempts++;
        log(`Attempt ${attempts}: an error occurred. ${error.message}`);
        if (attempts >= maxAttempts) {
          throw new Error(
            `Failed to call Gemini API after ${maxAttempts} attempts.`
          );
        }
      }
    }
  }
});</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#log">log</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Sep 05 2025 15:54:09 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
